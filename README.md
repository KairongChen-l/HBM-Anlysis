# 基于LLVM静态分析的带宽敏感性数据识别

## 根目录下通过以下步骤以及编译：
```bash
mkdir build
cd build
cmake ..
make
```



## 概述

这是一个用于自动识别和优化高带宽内存(HBM)使用的 LLVM 编译器 Pass。它通过复杂的静态分析来识别内存密集型操作，并评估哪些内存分配适合放置到 HBM 中以提高性能。本 Pass 不仅进行分析，还可以自动转换代码，将普通内存分配替换为 HBM 特定的分配。

## 功能特点

1. **多维静态分析**：全面分析内存访问模式、并行度、数据流和依赖关系
2. **基于评分的决策**：为每个内存分配计算综合评分，确定最适合 HBM 的候选者
3. **代码自动转换**：将高评分的 `malloc`/`new` 调用自动转换为 HBM 分配函数
4. **详细报告生成**：输出 JSON 格式的详细分析报告
5. **高度可配置**：通过命令行选项调整分析参数和阈值

## 分析组件详解

### 带宽分析器 (BandwidthAnalyzer)

带宽分析器评估内存操作的带宽敏感性，主要分析：

- **流式访问模式**：识别连续或固定步长的内存访问
- **循环内访问**：评估循环内的内存操作频率和密度
- **向量化访问**：检测 SIMD 操作和向量化指令
- **时间局部性**：评估数据重用模式对 CPU 缓存的影响
- **内存冲突**：分析可能的内存访问冲突

带宽评分计算考虑以下因素：
- 基础访问类型（读/写）的评分
- 循环深度和迭代次数
- 并行度和向量化水平
- 数据流模式和混乱度

### 并行度分析器 (ParallelismAnalyzer)

并行度分析器评估并行执行环境中的内存访问模式：

- **并行框架检测**：识别 OpenMP、CUDA、TBB 等并行框架
- **线程访问模式**：
  * 分区访问：每个线程访问独立内存区域
  * 共享只读：多线程共享读取同一区域
  * 共享写入：多线程写入同一区域（潜在冲突）
  * 原子访问：使用原子操作的内存访问
  * 伪共享：不同线程访问同一缓存行的不同部分
- **线程数估计**：根据并行框架和模式估计并行线程数

### 步长分析器 (StrideAnalyzer)

步长分析器研究内存访问的步长模式：

- **步长类型分类**：
  * 常量步长：固定距离的访问
  * 线性步长：步长呈线性变化
  * 复杂步长：有规律但复杂的步长
  * 不规则步长：无明显规律的步长
- **流式访问检测**：识别适合流水线优化的访问模式

### 向量化分析器 (VectorizationAnalyzer)

向量化分析器检测向量操作和 SIMD 指令：

- **向量指令识别**：检测使用向量数据类型的指令
- **SIMD 内联函数检测**：识别向量内联函数
- **向量化循环模式**：分析循环是否适合向量化
- **向量宽度分析**：确定向量操作的宽度

### 时间局部性分析器 (TemporalLocalityAnalyzer)

时间局部性分析器评估数据重用模式：

- **局部性级别分类**：
  * 极佳：高频重用，缓存高效
  * 良好：合理重用，缓存效率尚可
  * 中等：有限重用，缓存效果一般
  * 差：几乎无重用，缓存效果差
- **重用距离估计**：评估两次访问相同数据之间的指令数
- **重用频率计算**：计算数据重用的频率

### 内存库冲突分析器 (BankConflictAnalyzer)

内存库冲突分析器评估 HBM 内部库冲突可能性：

- **冲突类型识别**：
  * 同库访问冲突
  * 跨步冲突
  * 随机冲突
  * 部分行访问
  * 通道不平衡
- **冲突率估计**：估计访问模式导致的冲突概率
- **性能影响评估**：评估冲突对性能的影响程度

### 竞争分析器 (ContentionAnalyzer)

竞争分析器识别并发环境中的内存竞争：

- **竞争类型识别**：
  * 伪共享：不同线程访问同一缓存行
  * 原子竞争：原子操作的高频竞争
  * 锁竞争：共享锁导致的竞争
  * 带宽竞争：并行访问导致的带宽饱和
- **竞争概率评估**：估计竞争发生的概率
- **竞争分数计算**：计算竞争对 HBM 使用效益的影响

### 跨函数分析器 (CrossFunctionAnalyzer)

跨函数分析器追踪指针在函数间的传递：

- **指针传递追踪**：识别指针传递到的所有函数
- **热函数识别**：检测使用指针的高频（热）函数
- **外部函数传播**：评估指针传递到外部函数的情况

### 数据流分析器 (DataFlowAnalyzer)

数据流分析器研究内存分配的生命周期：

- **生命周期阶段识别**：
  * 分配阶段：内存初始分配
  * 初始化阶段：初始数据写入
  * 活跃使用阶段：频繁读写
  * 只读阶段：只读访问
  * 休眠阶段：很少或不使用
  * 释放阶段：内存释放
- **使用密度计算**：评估每个阶段的使用频率

### 依赖链分析器 (DependencyChainAnalyzer)

依赖链分析器构建并分析内存操作的依赖关系：

- **依赖图构建**：创建指令间的依赖关系图
- **关键路径识别**：确定执行中的关键路径
- **延迟敏感度分析**：评估操作对内存延迟的敏感程度
- **带宽敏感度分析**：评估操作对内存带宽的敏感程度

### 循环分析器 (LoopAnalyzer & LoopUtils)

循环分析器研究循环结构和内存访问模式：

- **循环嵌套分析**：评估嵌套循环结构
- **循环迭代次数估计**：估计循环执行次数
- **数据局部性评估**：分析循环中的数据局部性
- **交错访问模式检测**：识别多数组交错访问模式

## 主要 Pass 组件

### 函数分析 Pass (FunctionAnalysisPass)

函数分析 Pass 是函数级分析的入口：

- **内存分配识别**：识别函数中的 `malloc`/`new` 调用
- **分析协调**：协调所有专业分析器的工作
- **综合评分计算**：根据多维分析结果计算最终评分
- **结果收集**：收集并存储每个分配的分析结果

### 模块转换 Pass (ModuleTransformPass)

模块转换 Pass 处理整个模块的分析结果：

- **结果聚合**：收集所有函数的分析结果
- **HBM 决策**：基于评分确定哪些分配移至 HBM
- **代码转换**：将普通内存分配替换为 HBM 分配
- **报告生成**：生成分析和转换的 JSON 报告

## 使用方法

### 编译与安装

1. 确保已安装 LLVM 开发环境（建议 LLVM 14 或更高版本）
2. 编译 Pass：
   ```bash
   mkdir build && cd build
   cmake -DLLVM_DIR=/path/to/llvm/lib/cmake/llvm ..
   make
   ```
3. 生成的共享库（.so 文件）即可用于 LLVM 的编译流程

### 在编译流程中使用

Pass 可以通过 `opt` 工具与 LLVM 编译流程集成：

```bash
# 仅分析模式
opt -load-pass-plugin=./libHBMPass.so -passes="hbm-transform" \
    -hbm-analysis-only -hbm-report-file=report.json input.ll -o output.ll

# 完整转换模式
opt -load-pass-plugin=./libHBMPass.so -passes="hbm-transform" \
    -hbm-report-file=report.json input.ll -o output.ll
```

### 命令行选项

- `-hbm-threshold=<double>`：HBM 使用阈值（默认：50.0）
- `-hbm-parallel-bonus=<double>`：并行使用额外评分（默认：20.0）
- `-hbm-stream-bonus=<double>`：流式使用额外评分（默认：10.0）
- `-hbm-vector-bonus=<double>`：向量化使用额外评分（默认：5.0）
- `-hbm-access-base-read=<double>`：基础读取评分（默认：5.0）
- `-hbm-access-base-write=<double>`：基础写入评分（默认：8.0）
- `-hbm-bandwidth-scale=<double>`：带宽使用缩放因子（默认：1.0）
- `-hbm-report-file=<string>`：分析报告输出路径（默认：report.json）
- `-hbm-analysis-only`：仅执行分析，不转换代码（默认：false）

## 分析报告解读

分析报告以 JSON 格式输出，包含以下主要信息：

1. **基本信息**：
   - 源码位置
   - 分配大小
   - 循环深度和迭代次数

2. **状态标志**：
   - 是否并行
   - 是否向量化
   - 是否流式访问
   - 是否线程分区
   - 是否可能冲突

3. **评分组成**：
   - 总评分
   - 流式评分
   - 向量化评分
   - 并行评分
   - SSA 复杂度惩罚
   - 混乱度惩罚
   - 冲突惩罚

4. **扩展分析**：
   - 跨函数分析结果
   - 数据流分析结果
   - 竞争分析结果
   - 时间局部性分析结果
   - 内存库冲突分析结果
   - 依赖链分析结果

## 最佳实践

1. **先进行分析**：使用 `-hbm-analysis-only` 先进行分析，检查报告以确定合适的阈值
2. **调整阈值**：根据报告中的评分分布，调整 `-hbm-threshold` 值
3. **关注大内存分配**：特别关注报告中大型内存分配的评分情况
4. **逐步应用**：从少量高评分分配开始，逐步增加 HBM 使用范围
5. **测试性能**：每次更改后测试应用程序性能，确认 HBM 优化的效果

## 注意事项

1. HBM 容量有限：默认假设 HBM 容量为 16GB，超出时将不会转换更多分配
2. 确保 HBM 分配函数可用：代码转换假设存在 `hbm_malloc` 函数
3. 分析评分是相对的：评分主要用于比较不同分配的 HBM 适用性
4. 运行时行为可能与静态分析有差异：实际程序的动态行为可能与静态分析预测有所不同

通过本 LLVM Pass，您可以自动识别和优化程序中适合使用高带宽内存的部分，充分发挥 HBM 的性能优势，而无需大量手动代码修改。

## TODO
这是我修改完的版本，目前的代码已经没有任何编译错误，也能正常分析和转换内存分配函数。我需要你为我检查代码，然后修缮一些代码。我需要将这个Pass用在分析大型应用比如HPC应用上，他们会有专门的构建文件。所以我应该做一些什么修改，给出修改的具体位置和具体内容。